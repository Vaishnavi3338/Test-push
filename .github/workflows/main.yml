
name: Auto_PR_for_manifests_branches

on:
  push:
    branches:
      - 'nbo-manifests/**'

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  auto-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Create or reuse PR to main
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const base = 'main'; // change if your default branch is 'master'
            const head = context.ref.replace('refs/heads/', '');
            const { owner, repo } = context.repo;

            if (head === base) {
              core.info(`Head is base (${base}); skipping.`);
              return;
            }

            let pr;
            try {
              const created = await github.rest.pulls.create({
                owner, repo, base, head,
                title: `Auto PR: ${head} â†’ ${base}`,
                body: `Automated PR for branch ${head} targeting ${base}.`
              });
              pr = created.data;
              core.info(`Created PR #${pr.number}`);
            } catch (e) {
              if (e.status === 422) {
                const { data: prs } = await github.rest.pulls.list({
                  owner, repo, state: 'open', base, head: `${owner}:${head}`
                });
                if (prs.length === 0) throw e;
                pr = prs[0];
                core.info(`Reusing existing PR #${pr.number}`);
              } else {
                throw e;
              }
            }
            core.setOutput('pr_number', String(pr.number));

      # (Optional) If your ruleset requires branch up-to-date, try updating when behind/dirty
      - name: Update branch if PR is behind/dirty
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = Number(process.env.PR_NUMBER);
            const getPR = async () => (await github.rest.pulls.get({ owner, repo, pull_number: pr_number })).data;

            let pr = await getPR();
            const s = pr.mergeable_state;
            core.info(`Initial mergeable_state=${s}`);
            if (s === 'behind' || s === 'dirty') {
              try {
                await github.rest.pulls.updateBranch({ owner, repo, pull_number: pr_number });
                core.info('Triggered branch update to catch up with base.');
              } catch (e) {
                core.info(`UpdateBranch not possible or failed: ${e.message}`);
              }
            }
        env:
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}

      - name: Wait until PR is mergeable (clean), then merge
        uses: actions/github-script@v7
        with:
          script: |
            const base = 'main';                // keep consistent with first step
            const mergeMethod = 'merge';        // change to 'squash' or 'rebase' if your ruleset requires
            const { owner, repo } = context.repo;
            const pr_number = Number(process.env.PR_NUMBER);
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            const getPR = async () => (await github.rest.pulls.get({ owner, repo, pull_number: pr_number })).data;

            // Warm-up wait so checks start and mergeability is computed
            core.info('Warm-up: waiting 30s for checks/mergeability to initialize...');
            await sleep(30000);

            const maxWaitMs = 30 * 60 * 1000; // 30 minutes
            const intervalMs = 10 * 1000;
            const deadline = Date.now() + maxWaitMs;

            while (Date.now() < deadline) {
              const pr = await getPR();
              const s = pr.mergeable_state;
              core.info(`mergeable_state=${s}`);

              if (s === 'clean') break;

              if (s === 'behind' || s === 'dirty') {
                try {
                  await github.rest.pulls.updateBranch({ owner, repo, pull_number: pr_number });
                  core.info('Attempted branch update to catch up with base.');
                } catch (e) {
                  core.info(`UpdateBranch attempt failed or not allowed: ${e.message}`);
                }
              } else if (s === 'blocked') {
                core.info('Waiting for required checks/reviews per ruleset...');
              } else if (s === 'unstable' || s === 'unknown' || s === 'has_hooks') {
                core.info('Checks/hooks running or mergeability computing; waiting...');
              } else if (s === 'conflicting') {
                throw new Error('Merge conflicts detected. Please resolve conflicts on the branch.');
              } else if (s === 'draft') {
                throw new Error('PR is a draft. Mark it ready for review to allow merging.');
              }

              await sleep(intervalMs);
            }

            const final = await getPR();
            if (final.mergeable_state !== 'clean') {
              throw new Error(`Timeout waiting for protections. Final mergeable_state=${final.mergeable_state}`);
            }

            await github.rest.pulls.merge({
              owner, repo, pull_number: pr_number, merge_method: mergeMethod
            });
            core.info(`Merged PR #${pr_number} into ${base}.`);
        env:
          PR_NUMBER: ${{ steps.pr.outputs.pr_number
